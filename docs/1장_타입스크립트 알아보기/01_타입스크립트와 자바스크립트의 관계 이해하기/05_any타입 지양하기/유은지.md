# 아이템 1. 타입스크립트와 자바스크립트의 관계 이해하기

타입스크립트는 자바스크립트의 상위 집합이다.

## **TypeScript**

- JavaScript의 상위 집합으로 JavaScript의 모든 기능이 있음
- TypeScript **컴파일러를** 사용하여 ts(TypeScript)파일을 js(JavaScript) 파일로 변환, 쉽게 통합
- 정적 유형 검사 제공
- 클래스 기반 객체를 만들 수 있음
- 클래스 기반이므로 객체 지향 프로그래밍 언어로 상속, 캡슐화 및 생성자를 지원할 수 있음

## **TypeScript 장점**

### 런타임 에러 vs 컴파일 에러

- JavaScript는 런타임에서 에러가 발생함, TypeScript는 컴파일 과정에서 에러가 발생함
  - 프로그램의 규모가 커지게 되면 프로그램이 돌다가 에러가 발생하는 상황을 미리 예방할 수 있음

### IDE 결합성

- 클래스와 함수를 ctrl + click로 쉽게 역추적이 가능함

### 가독성

- 자료형을 명시함으로써 넣는 데이터와 반환되는 데이터를 쉽게 알 수 있음.

## **TypeScript 단점**

### 속도

tsc로 타입 체크를 하고 한 번 빌드하기 위해서 적지 않은 시간이 소모됨. 따라서 바벨과 협업을해 바벨에서 타입스크립트의 문법만 제거해 자바스크립트로 만들어주는 플러그인을 개발함. 따라서 tsc로 컴파일 하지 않고 그냥 타입스크립트를 자바스크립트로 만들고 번들 툴을 이용해 빌드하는 방식을 사용.

이후엔 esbuild가 등장해 엄청나게 빠르게 사용할 수 있도록 됨.

## **TypeScript 목표**

런타임에 오류를 발생시킬 코드를 미리 찾아 내는것

# 아이템 2. 타입스크립트 설정 이해하기

## 더 나은 타입안정성을 위한 옵션 1 : \***\*noImplicitAny\*\***

일반적인 함수의 인자 타입과 같이 타입을 직접 명시해주지 않으면 어떤 타입을 받을 것인지 추론할 수 없는 경우가 생깁니다.

이때 타입스크립트 컴파일러는 해당 요소의 타입을 `any`로 추론합니. 따라서 해당 요소는 모든 타입을 수용할 수 있게 됩니다. 이는 암시적으로 타이핑이 이뤄지는 것이기에 장기적으로 봤을 때 버그가 될 수 있는 지점입니다. 다른 사용자 (혹은 미래의 나)가 함수의 의도를 오인하고 잘못된 타입의 인자를 전달해줄 수 있기 때문입니다. 그러므로 지양해야 합니다.

이때 `noImplicitAny`라는 [tsconfig.json](https://typescript-kr.github.io/pages/tsconfig.json.html) 파일의 옵션을 `true`로 지정해주는 것이 좋습니다.

## \***\*더 나은 타입안정성을 위한 옵션 2 : noImplicitReturn\*\***

`noImplicitAny`와 같은 맥락의 tsconfig.json 파일의 옵션으로, 함수가 조건에 따라 명시적으로 `return`을 하지 않았을 때 에러를 발생시켜주는 기능입니다.

함수 내에 `return`문이 존재하지 않는다면 컴파일러는 해당 함수의 리턴타입을 `void`로 추론합니다. 따라서 문제가 발생하지 않습니다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2bf1ccc3-0032-4d9c-b7fc-6d5e45357ad9/Untitled.png)

하지만 위와 같이 분기에 따라 반환이 될 수도 있고, 되지 않을 수도 있는 경우에 `noImplicitReturn`옵션이 `true`라면 컴파일 에러가 발생합니다. 반환값이 `undefined`가 되기에 추후에 발생할 수 있는 버그를 미연에 방지할 수 있습니다.

## \***\*더 나은 타입안정성을 위한 옵션 3: strictNullCheck\*\***

객체 인덱싱을 하려고할 때 객체가 런타임에서 `undefined`, `null`이 나올 가능성이 있다면 에러를 출력합니다.

```jsx
const twoDimensionArray = [
  [1, 2],
  [2, 3],
  [4, 5],
];

const found = twoDimensionArray.find((el) => el[0] === 9);

console.log(found[1]);
```

find 메서드는 대상을 찾지 못하면 `undefined`를 반환합니다. 따라서 `found[1]`이라는 인덱싱은 가능할 수도, 불가능할 수도 있는 식입니다. `strictNullCheck`라는 옵션에 `true`값을 주면 해당 라인에 에러를 나타냅니다.

# 아이템 3 코드 생성과 타입이 관계없음을 이해하기

타입스크립트 컴파일러의 2가지 역할 ( 2개는 완전 독립적 )

- 최신 타입스크립트, 자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일함
- 코드의 타입 오류를 체크함

## 타입 오류가 있는 코드도 컴파일이 가능

- 컴파일과 타입 체크는 독립적으로 동작한다.
- 타입 오류가 있는 코드도 컴파일이 가능하다.
- 오류가 있을 때 컴파일 하지 않으려면 tsconfig.json에 noEmitOnError 설정하기

## 런타임에는 타입 체크가 불가능하다

- 자바스크립트로 컴파일 과정에서 모든 인터페잇, 타입, 타입 구문은 그냥 제거된다.

## 타입 연산은 런타임에 영향을 주지 않는다

- 값을 정제하기 위해서는 런타임의 타입을 체크해야하고 자바스크립트 연산을 통해 변환 수행을 해야한다.
- 일반적으로 태그된 유니온과 속성 체크 방법을 사용한다.
- 또는 클래스와 같이 타입스크립트 타입과 런타입 값, 둘 다 제공하는 방법이 있다.

## 런타임 타입은 선언된 타입과 다를 수 있습니다

- 타입스크립트 → 자바스크립트 컴파일 과정에서 벗겨지기에 선언된 타입이 언제든 달라질 수 있다는 것을 명심해야 한다

## 타입스크립트 타입으로는 함수를 오버로드할 수 없습니다

- 오버로딩 : 동일한 이름에 매개변수만 다른 여러 버전의 함수 허용하는 것
- 타입스크립트는 타입과 런타임 동작이 무관하기 때문에 함수 오버로딩이 불가능하다
- 하나의 함수에 대해 여러 개의 선언문을 작성할 수 있지만 구현체는 오직 하나 뿐이다.

## 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다

- 타입스크립트 컴파일러는 빌드타임 오버헤드가 있음
